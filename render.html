<!doctype html>
<html>
<head>
	<script>
	var THREE = {};
	</script>
	<script src="Vector3.js"></script>
	<script src="Matrix.js"></script>
	<script src="Math.js"></script>
	<script src="head-model.js"></script>
	<script src="texture-test.js"></script>
	<script src="texture-head.js"></script>
	<script src="model-parser-and-stuff.js"></script>
</head>
<body>
	<div id="wrapper">
	</div>
	<script>
	drawModelWithTestTexture();
	
	function drawModelWithTestTexture() {
		console.log('loading texture test');
		loadTexture(textureRestangleWithFourColors, function(texture){
			console.log('texture test is loaded');
			console.log('loading model');
			var headModel = new Model(headModelTxt, texture);
			console.log('model loaded, begin render');
			render(document.querySelector('#wrapper'), headModel, texture, 500, 500, false, drawModelWithNormalTexture);
		});
	}
	
	function drawModelWithNormalTexture() {
		console.log('loading texture head');
		loadTexture(textureHeadDiffuse, function(texture){
			console.log('texture head is loaded');
			console.log('loading model');
			var headModel = new Model(headModelTxt, texture);
			console.log('model loaded, begin render');
			render(document.querySelector('#wrapper'), headModel, texture, 500, 500, false);
		});
	}
	
	function render(wrapper, model, texture, width, height, drawSlow, done) {
		done = done || function(){};
		
		var image, zbuffer;
		var depth = 255;
		drawSlow = !!drawSlow;
		var light_dir = new THREE.Vector3(0, 0, -1);
		light_dir.normalize();
		var eye = new THREE.Vector3(1, 1, 3);
		var center = new THREE.Vector3(0, 0, 0);
		var camera = new THREE.Vector3(0, 0, 3);
		var Projection = Matrix.identity(4);
		var ViewPort   = viewport(width/8, height/8, width*3/4, height*3/4);
		Projection.row(3)[2] = -1./camera.z;
		
		texture.imageObj.style.width = '128px';
		texture.imageObj.style.height = '128px';
		texture.imageObj.style.display = 'block';
		texture.imageObj.style.float = 'left';
		wrapper.appendChild(texture.imageObj);
	
		image = new TGAEmulator(width, height, wrapper);
		image.flip_vertically();

		zbuffer = Array(width*height);
		for (var i=0; i<width*height; i++) {
			zbuffer[i] = Number.MIN_VALUE;
		}
		
		if(!drawSlow) {
			var i = 0;
			//once at half second free a main loop for redraw screen
			var lastTime = +new Date();
			drawBulk();
			function drawBulk() {
				var t=0;
				for(i;i<model.faces.length;i++) {
					drawFace(i);
					if(+new Date() - lastTime >= 500) break;
				}
				lastTime = +new Date();
				if(i<model.faces.length)
					setTimeout(drawBulk);
				else {
					console.log('render completed');
					done();
				}
				
			}
		} else {
			drawFace(0);
		}
		
		function m2v(m) {
			return new THREE.Vector3(m.row(0)[0]/m.row(3)[0], m.row(1)[0]/m.row(3)[0], m.row(2)[0]/m.row(3)[0]);
		}
		
		function v2m(v) {
			var m = new Matrix(4, 1);
			m.row(0)[0] = v.x;
			m.row(1)[0] = v.y;
			m.row(2)[0] = v.z;
			m.row(3)[0] = 1.;
			return m;
		}
		
		function viewport(x, y, w, h) {
			var m = Matrix.identity(4);
			m.row(0)[3] = x+w/2.;
			m.row(1)[3] = y+h/2.;
			m.row(2)[3] = depth/2.;

			m.row(0)[0] = w/2.;
			m.row(1)[1] = h/2.;
			m.row(2)[2] = depth/2.;
			return m;
		}
		
		function drawFace(i) {
			var face = model.faces[i];
			if(typeof face === 'undefined') {
				console.log('render complete');
				done();
				return;
			}
			var screen_coords = Array(3);
			var world_coords = Array(3);
			var worldCoords = Array(3);
			for(var j=0;j<3;j++) {
				var v = model.verts[face[j].v];
				//screen_coords[j] =  m2v(ViewPort*Projection*v2m(v));
				screen_coords[j] =  m2v(ViewPort.mul(Projection).mul(v2m(v))).toInt();
				// screen_coords[j] = {
				// 	x: ~~((v.x+1)*width/2),
				// 	y: ~~((v.y+1.)*height/2),
				// 	z: ~~((v.z+1.)*depth/2)
				// };
				world_coords[j]  = v;
				worldCoords[j] = new THREE.Vector3(v.x, v.y, v.z);
			}
			function randColor() {
				return [~~(Math.random()*255),~~(Math.random()*255),~~(Math.random()*255), 255];
			}
			
			var a = (worldCoords[2].sub(worldCoords[0]));
			var b = (worldCoords[1].sub(worldCoords[0]));
		
			var n = a.cross(b);
			n.normalize();
		
			var intensity = n.dot(light_dir);
			if(intensity > 0) {
				var uv = Array(3);
				for(var k=0;k<3;k++)
					uv[k] = model.uv(i, k);
				triangle(screen_coords[0], screen_coords[1], screen_coords[2], uv[0], uv[1], uv[2], image, intensity, zbuffer);
			}
			if(drawSlow)
				setTimeout(drawFace, 1, ++i);
		}
	
		function triangle(t0, t1, t2, uv0, uv1, uv2, image, intensity, zbuffer) {
			var args = arguments;
			function swap(name1, name2) {
				var i = 0;
				var argNames = {t0:i++, t1:i++, t2:i++, uv0:i++, uv1:i++, uv2:i++, image:i++, color:i++};
				i = args[argNames[name1]];
				args[argNames[name1]] = args[argNames[name2]];
				args[argNames[name2]] = i;
			}
		
			if (t0.y==t1.y && t0.y==t2.y) return; // i dont care about degenerate triangles
			// sort the vertices, t0, t1, t2 lower-to-upper (bubblesort yay!)
			if (t0.y>t1.y) {
				swap('t0', 't1');
				swap('uv0', 'uv1');
			}
			if (t0.y>t2.y) {
				swap('t0', 't2');
				swap('uv0', 'uv2');
			}
			if (t1.y>t2.y) {
				swap('t1', 't2');
				swap('uv1', 'uv2');
			}
		
			function vec(t) {
				return new THREE.Vector3(t.x, t.y, t.z);
			}
		
			var total_height = ~~(t2.y-t0.y);
			for(var i=0;i<total_height;i++) {
				var second_half = i>t1.y-t0.y || t1.y==t0.y;
				var segment_height = ~~(second_half ? t2.y-t1.y : t1.y-t0.y);
				//int segment_height = second_half ? t2.y-t1.y : t1.y-t0.y;
				var alpha = i/total_height;
				//float alpha = (float)i/total_height;
				var beta  = (i-(second_half ? t1.y-t0.y : 0))/segment_height; // be careful: with above conditions no division by zero here
				//float beta  = (float)(i-(second_half ? t1.y-t0.y : 0))/segment_height;
				var A = vec(t0).add(vec(t2).sub(vec(t0)).multiplyScalar(alpha)).toInt();
				// Vec3i A =               t0 + Vec3f(t2-t0)*alpha;
				var B = second_half ? 
							vec(t1).add(  vec(t2).sub(vec(t1)).multiplyScalar(beta)  ).toInt() :
							vec(t0).add(  vec(t1).sub(vec(t0)).multiplyScalar(beta)  ).toInt();
				// Vec3i B = second_half ? t1 + Vec3f(t2-t1)*beta : t0 + Vec3f(t1-t0)*beta;
			
				var uvA = vec(uv0).add(  vec(uv2).sub(vec(uv0)).multiplyScalar(alpha)   ).toInt();
				//Vec2i uvA =               uv0 +      (uv2-uv0)*alpha;
			
				var uvB = second_half ? 
							vec(uv1).add(  vec(uv2).sub(vec(uv1)).multiplyScalar(beta)  ).toInt(): 
							vec(uv0).add(  vec(uv1).sub(vec(uv0)).multiplyScalar(beta)  ).toInt();
				//Vec2i uvB = second_half ? uv1 +      (uv2-uv1)*beta : uv0 +      (uv1-uv0)*beta;
				if(A.x > B.x) {
					var t = A;
					A = B;
					B = t;
				
					t = uvA;
					uvA = uvB;
					uvB = t;
				}
			
				for (var j=~~(A.x); j<=~~(B.x); j++) {
					// float phi = B.x==A.x ? 1. : (float)(j-A.x)/(float)(B.x-A.x);
					var phi = B.x == A.x ? 1. : (j-A.x)/(B.x-A.x);
					//Vec3i P = Vec3f(A) + Vec3f(B-A)*phi;
					var P = vec(A).add(  vec(B).sub(vec(A)).multiplyScalar(phi)  ).toInt();
				
					// Vec2i uvP =     uvA +   (uvB-uvA)*phi;
					var uvP = vec(uvA).add(  vec(uvB).sub(vec(uvA)).multiplyScalar(phi)  ).toInt();
					P.x = j;
					P.y = i+t0.y;
					var idx = ~~( ~~(P.x) + ~~(P.y)*width );
					if (zbuffer[idx] < P.z) {
						zbuffer[idx] = ~~(P.z);
						var color = model.diffuse(uvP);
						image.set(P.x, P.y, [color.r*intensity, color.g*intensity, color.b*intensity, 255]);
					}
				}
			}
		}
	}
	</script>
</body>
</html>