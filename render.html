<!doctype html>
<html>
<head>
	<script>
	var THREE = {};
	</script>
	<script src="Vector3.js"></script>
	<script src="Matrix3.js"></script>
	<script src="Math.js"></script>
	<script src="head-model.js"></script>
	<script src="texture-test.js"></script>
	<script src="texture-head.js"></script>
	<script src="model-parser-and-stuff.js"></script>
</head>
<body>
	<div id="wrapper">
	</div>
	<script>
	render(document.querySelector('#wrapper'), headModelTxt, textureHeadDiffuse, 500, 500, false);
	render(document.querySelector('#wrapper'), headModelTxt, textureRestangleWithFourColors, 500, 500, false);
	
	function render(wrapper, modelTxt, textureBase64, width, height, drawSlow) {
		var model, image, zbuffer;
		var depth = 255;
		var texture;
		drawSlow = !!drawSlow;
		
		loadTexture(textureBase64, function(textureData){
			texture = textureData;
		
			model = new Model(modelTxt, texture);
	
			textureData.imageObj.style.width = '128px';
			textureData.imageObj.style.height = '128px';
			textureData.imageObj.style.display = 'block';
			textureData.imageObj.style.float = 'left';
			wrapper.appendChild(textureData.imageObj);
		
			image = new TGAEmulator(width, height, wrapper);
			image.flip_vertically();

			function Vec2i(x, y) {
				return {x:x,y:y};
			}

			var t0 = [Vec2i(10, 70),   Vec2i(50, 160),  Vec2i(70, 80)];
			var t1 = [Vec2i(180, 50),  Vec2i(150, 1),   Vec2i(70, 180)];
			var t2 = [Vec2i(90, 200), Vec2i(5, 215), Vec2i(80, 250)];
	
			zbuffer = Array(width*height);
			for (var i=0; i<width*height; i++) {
				zbuffer[i] = Number.MIN_VALUE;
			}
			
			if(!drawSlow) {
				var i = 0;
				//once at second free a main loop for redraw screen
				var lastTime = +new Date();
				drawBulk();
				function drawBulk() {
					var t=0;
					for(i;i<model.faces.length;i++) {
						drawFace(i);
						if(+new Date() - lastTime >= 1000) break;
					}
					lastTime = +new Date();
					if(i<model.faces.length)
						setTimeout(drawBulk);
					else
						console.log('render completed');
				}
			} else {
				drawFace(0);
			}
		});
		
		function line(x0, y0, x1, y1, image, color) {
			var args = arguments;
			function swap(name1, name2) {
				var i = 0;
				var argNames = {x0:i++, y0:i++, x1:i++, y1:i++, image:i++, color:i++};
				i = args[argNames[name1]];
				args[argNames[name1]] = args[argNames[name2]];
				args[argNames[name2]] = i;
			}
			var steep = false;
			if (Math.abs(x0-x1)<Math.abs(y0-y1)) { // if the line is steep, we transpose the image
				swap('x0', 'y0');
				swap('x1', 'y1');
				steep = true;
			}
			if (x0>x1) { // make it left-to-right
				swap('x0', 'x1');
				swap('y0', 'y1');
			}
			for (var x=x0; x<=x1; x++) {
				var t = (x-x0)/(x1-x0);
				var y = ~~(y0*(1.-t) + y1*t); //Math.floor on 0 returns NaN
				if (steep) {
					image.set(y, x, color); // if transposed, de-transpose
				} else {
					image.set(x, y, color);
				}
			}
		}
	
		function triangle(t0, t1, t2, uv0, uv1, uv2, image, intensity, zbuffer) {
			var args = arguments;
			function swap(name1, name2) {
				var i = 0;
				var argNames = {t0:i++, t1:i++, t2:i++, uv0:i++, uv1:i++, uv2:i++, image:i++, color:i++};
				i = args[argNames[name1]];
				args[argNames[name1]] = args[argNames[name2]];
				args[argNames[name2]] = i;
			}
		
			if (t0.y==t1.y && t0.y==t2.y) return; // i dont care about degenerate triangles
			// sort the vertices, t0, t1, t2 lower-to-upper (bubblesort yay!)
			if (t0.y>t1.y) {
				swap('t0', 't1');
				swap('uv0', 'uv1');
			}
			if (t0.y>t2.y) {
				swap('t0', 't2');
				swap('uv0', 'uv2');
			}
			if (t1.y>t2.y) {
				swap('t1', 't2');
				swap('uv1', 'uv2');
			}
		
			function vec(t) {
				return new THREE.Vector3(t.x, t.y, t.z);
			}
		
			var total_height = ~~(t2.y-t0.y);
			for(var i=0;i<total_height;i++) {
				var second_half = i>t1.y-t0.y || t1.y==t0.y;
				var segment_height = ~~(second_half ? t2.y-t1.y : t1.y-t0.y);
				//int segment_height = second_half ? t2.y-t1.y : t1.y-t0.y;
				var alpha = i/total_height;
				//float alpha = (float)i/total_height;
				var beta  = (i-(second_half ? t1.y-t0.y : 0))/segment_height; // be careful: with above conditions no division by zero here
				//float beta  = (float)(i-(second_half ? t1.y-t0.y : 0))/segment_height;
				var A = vec(t0).add(vec(t2).sub(vec(t0)).multiplyScalar(alpha)).toInt();
				// Vec3i A =               t0 + Vec3f(t2-t0)*alpha;
				var B = second_half ? 
							vec(t1).add(  vec(t2).sub(vec(t1)).multiplyScalar(beta)  ).toInt() :
							vec(t0).add(  vec(t1).sub(vec(t0)).multiplyScalar(beta)  ).toInt();
				// Vec3i B = second_half ? t1 + Vec3f(t2-t1)*beta : t0 + Vec3f(t1-t0)*beta;
			
				var uvA = vec(uv0).add(  vec(uv2).sub(vec(uv0)).multiplyScalar(alpha)   ).toInt();
				//Vec2i uvA =               uv0 +      (uv2-uv0)*alpha;
			
				var uvB = second_half ? 
							vec(uv1).add(  vec(uv2).sub(vec(uv1)).multiplyScalar(beta)  ).toInt(): 
							vec(uv0).add(  vec(uv1).sub(vec(uv0)).multiplyScalar(beta)  ).toInt();
				//Vec2i uvB = second_half ? uv1 +      (uv2-uv1)*beta : uv0 +      (uv1-uv0)*beta;
				if(A.x > B.x) {
					var t = A;
					A = B;
					B = t;
				
					t = uvA;
					uvA = uvB;
					uvB = t;
				}
			
				for (var j=~~(A.x); j<=~~(B.x); j++) {
					// float phi = B.x==A.x ? 1. : (float)(j-A.x)/(float)(B.x-A.x);
					var phi = B.x == A.x ? 1. : (j-A.x)/(B.x-A.x);
					//Vec3i P = Vec3f(A) + Vec3f(B-A)*phi;
					var P = vec(A).add(  vec(B).sub(vec(A)).multiplyScalar(phi)  ).toInt();
				
					// Vec2i uvP =     uvA +   (uvB-uvA)*phi;
					var uvP = vec(uvA).add(  vec(uvB).sub(vec(uvA)).multiplyScalar(phi)  ).toInt();
					P.x = j;
					P.y = i+t0.y;
					var idx = ~~( ~~(P.x) + ~~(P.y)*width );
					if (zbuffer[idx] < P.z) {
						zbuffer[idx] = ~~(P.z);
						var color = model.diffuse(uvP);
						image.set(P.x, P.y, [color.r*intensity, color.g*intensity, color.b*intensity, 255]);
					}
				}
			}
		}
	
		function drawFace(i) {
			var face = model.faces[i];
			if(typeof face === 'undefined') {
				console.log('render complete');
				return;
			}
			var screen_coords = Array(3);
			var world_coords = Array(3);
			var worldCoords = Array(3);
			for(var j=0;j<3;j++) {
				var v = model.verts[face[j].v];
				screen_coords[j] = {
					x: ~~((v.x+1)*width/2),
					y: ~~((v.y+1.)*height/2),
					z: ~~((v.z+1.)*depth/2)
				};
				world_coords[j]  = v;
				worldCoords[j] = new THREE.Vector3(v.x, v.y, v.z);
			}
			function randColor() {
				return [~~(Math.random()*255),~~(Math.random()*255),~~(Math.random()*255), 255];
			}
		
			var light_dir = new THREE.Vector3(0, 0, -1);
			var a = (worldCoords[2].sub(worldCoords[0]));
			var b = (worldCoords[1].sub(worldCoords[0]));
		
			var n = a.cross(b);
			n.normalize();
		
			var intensity = n.dot(light_dir);
			if(intensity > 0) {
				var uv = Array(3);
				for(var k=0;k<3;k++)
					uv[k] = model.uv(i, k);
				triangle(screen_coords[0], screen_coords[1], screen_coords[2], uv[0], uv[1], uv[2], image, intensity, zbuffer);
			}
			if(drawSlow)
				setTimeout(drawFace, 1, ++i);
		}
	}
	</script>
</body>
</html>